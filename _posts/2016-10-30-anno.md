---
layout: post
title: annotation
---

[어노테이션(annotation)의 용도]
1. @Override 어노테이션처럼 컴파일러를 위한 정보를 제공하기 위한 용도
2. 스프링 프레임워크의 @Controller 어노테이션처럼 런타임에 리플렉션을 이용해서 특수 기능을 추가하기 위한 용도
3. 컴파일 과정에 어노테이션 정보로부터 코드를 생성하기 위한 용도

*자바 리플렉션: 다른언어에는 존재하지 않는 특별한 기능, 컴파일 시간이 아닌 실행시간에 동적으로 특정 클래스의 정보를 객체를 통해 분석 및 추출해내는 프로그래밍 기법

[어노테이션 선업법]
public @interface ClassInfo
{
   // 엘리먼트들

   /*
   String value();
   String[] author();
   int revision() default 0; //엘리먼트에 디폴트값 주는법
   */
}

[어노테이션 사용]
// SomeClass 클래스에서 @ClassInfo 어노테이션을 적용
@ClassInfo(value = "클래스입니다", author = {"최범균"})
public class SomeClass
{
   ...
}

[어노테이션 유의사항]
-엘리먼트가 기본 값을 갖고 있지 않을 경우 반드시 엘리먼트의 값을 지정해 주어야 한다.

-기본 값을 가진 엘리먼트는 값을 지정하지 않을 경우 값으로 기본 값을 갖게 된다

-엘리먼트의 타입이 배열인 경우 중괄호를 이용해서 값 목록을 전달한다

[자바에서 기본 제공]
@Override: 해당 메소드가 부모 클래스에 있는 메소드를 오버라이드 했다는 것을 명시적으로 선언
@Deprecated: 더 이상 사용되지 않은 클래스나 메소드 앞에 추가해준다.
@SuppressWarnings: 개발자고 경고나는 걸 알고있다는 걸 알려줌.

<메타 어노테이션>
[@Target] 어떤 것에 어노테이션을 적용할 지 선언
- Target을 지정함으로 어노테이션유형이 잘못 사용되는것을 방지할수 있다. 지정하지 않으면 모든 대상에 사용가능

- Target을 지정하려면 먼저 ElementType을 알아야 한다.

※java.lang.annotation.ElementType 열거 타입에 다음과 같이 정의되어 있다
ElmentType.TYPE : 클래스, 인터페이스, 열거 타입
ElmentType.ANNOTATION_TYPE : 어노테이션 타입
ElmentType.FIELD : 필드
ElmentType.CONSTRUCTOR : 생성자
ElmentType.METHOD : 메서드
ElmentType.PARAMETER : 파라미터
ElmentType.LOCAL_VARIABLE : 로컬 변수
ElmentType.PACKAGE : 패키지

[@Retention] 얼마나 오래 어노테이션 정보가 유지되는 지를 선언
- java.lang.annotation.RetensionPolicy 열거 타입을 value 엘리먼트의 값으로 가질 수 있으며, 다음의 세 가지 값을 정의

RetentionPolicy.SOURCE : 어노테이션 정보가 컴파일시 사라짐 
(소스 코드 수준에서만 어노테이션 정보를 유지한다. 소스 코드를 분석할 때만 의미가 있다.)
RetentionPolicy.CLASS : 클래스 파일에 있는 어노테이션 정보가 컴파일러에 의해 참조 가능함. 하지만 가상 머신에서는 사라짐. ( 소스 코드에 명시된 어노테이션 정보를 클래스 파일에 기록한다. 하지만 리플렉션을 이용해서 어노테이션 정보를 구할 수는 없다)
RetentionPolicy.RUNTIME : 실행시 어노테이션 정보가 가상 머신에 의해서 참조 가능(소스 코드에 명시된 어노테이션 정보를 클래스 파일에 기록한다. 또한, 리플렉션을 이용해서 런타임에 어노테이션 정보를 구할 수 있다)
